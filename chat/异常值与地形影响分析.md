# å¼‚å¸¸å€¼ä¸åœ°å½¢å½±å“åˆ†æ
_Exported on 9/1/2025 at 01:34:00 GMT+8 from Cursor (1.5.7)_

---

**User**

è¿™å¼ å›¾ç‰‡å·¦å›¾æ˜¾ç¤ºäº†ä½œä¸šåŒºåŸŸå†…å™ªå£°åƒç´ å’Œåœ°å½¢å›¾ï¼›å™ªå£°å€¼æ˜¯æ ¹æ®æœ€æ™´æœ—å¤©ç©ºå›¾åƒä¸Šé›·è¾¾ä¿¡å·çš„å¹³å‡å€¼è®¡ç®—å¾—å‡ºçš„ï¼Œæ˜¾ç¤ºå‡ºç³»ç»Ÿæ€§ä¼ªå½±ã€‚å³å›¾æ˜¾ç¤ºäº†TAASRAD19å¼‚å¸¸å€¼æ©è†œï¼›é»‘è‰²åƒç´ å¯¹åº”äºå¼‚å¸¸å€¼å’Œé›·è¾¾ä½œä¸šèŒƒå›´ä»¥å¤–çš„åŒºåŸŸã€‚æˆ‘çš„é—®é¢˜æ˜¯ï¼šå³å›¾ä¸­é—´çš„é»‘è‰²åƒç´ æ˜¯å¼‚å¸¸å€¼ï¼Œæ˜¯ä¸æ˜¯æœ‰å¯èƒ½æ˜¯å› ä¸ºåœ°å½¢çš„åŸå› é€ æˆè¿™äº›åŒºåŸŸçš„å€¼ä¸å¯ç”¨ï¼Ÿæ‰€ä»¥éœ€è¦åœ¨è®­ç»ƒæ—¶å°†æ‰€æœ‰å¸§çš„å¼‚å¸¸åŒºåŸŸmaskæ‰ï¼Ÿ

---

**Cursor**

æ‚¨çš„é—®é¢˜éå¸¸ä¸“ä¸šï¼è®©æˆ‘å…ˆæŸ¥çœ‹ä¸€ä¸‹TAASRAD19é¡¹ç›®ä¸­å…³äºå¼‚å¸¸å€¼æ©è†œç”Ÿæˆçš„å…·ä½“å®ç°ï¼Œç„¶åç»“åˆæ‚¨æä¾›çš„å›¾ç‰‡æ¥è¯¦ç»†è§£é‡Šè¿™ä¸ªé—®é¢˜ã€‚


ç°åœ¨è®©æˆ‘æŸ¥çœ‹ä¸€ä¸‹settings.pyä¸­çš„MASKå®šä¹‰ï¼Œä»¥åŠè®­ç»ƒè¿‡ç¨‹ä¸­å¦‚ä½•ä½¿ç”¨æ©è†œï¼š


ç°åœ¨è®©æˆ‘åˆ›å»ºä¸€ä¸ªä»»åŠ¡åˆ—è¡¨æ¥ç³»ç»Ÿåœ°å›ç­”æ‚¨çš„é—®é¢˜ï¼š


åŸºäºå¯¹TAASRAD19é¡¹ç›®ä»£ç çš„æ·±å…¥åˆ†æï¼Œæˆ‘æ¥è¯¦ç»†å›ç­”æ‚¨çš„é—®é¢˜ï¼š

## ğŸ¯ æ‚¨çš„åˆ†æå®Œå…¨æ­£ç¡®ï¼

æ‚¨æå‡ºçš„é—®é¢˜éå¸¸ä¸“ä¸šä¸”å‡†ç¡®ã€‚è®©æˆ‘ä»æŠ€æœ¯è§’åº¦è¯¦ç»†è§£é‡Šï¼š

### 1. å¼‚å¸¸å€¼æ©è†œç”Ÿæˆç®—æ³•åˆ†æ

ä» `03_generate_mask.py` çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œå¼‚å¸¸å€¼æ©è†œçš„ç”Ÿæˆé‡‡ç”¨äº†**é©¬å“ˆæ‹‰è¯ºæ¯”æ–¯è·ç¦»ï¼ˆMahalanobis Distanceï¼‰**çš„ç»Ÿè®¡æ–¹æ³•ï¼š

```python
# æ ¸å¿ƒç®—æ³•é€»è¾‘
m = normalized_data[MASK].mean(axis=0, dtype=np.float64)  # è®¡ç®—å‡å€¼
S = np.cov(normalized_data[MASK], rowvar=False)           # è®¡ç®—åæ–¹å·®çŸ©é˜µ
Sinv = np.linalg.pinv(S)                                  # è®¡ç®—é€†çŸ©é˜µ

# å¯¹æ¯ä¸ªåƒç´ è®¡ç®—é©¬å“ˆæ‹‰è¯ºæ¯”æ–¯è·ç¦»
distances[i][j] = mahalanobis(normalized_data[i][j], m, Sinv)

# ä½¿ç”¨3å€æ ‡å‡†å·®ä½œä¸ºå¼‚å¸¸å€¼é˜ˆå€¼
mask = distances <= dist_mean + 3 * dist_stddev
```

**å…³é”®ç†è§£**ï¼šè¿™ä¸ªç®—æ³•é€šè¿‡åˆ†ææ¯ä¸ªåƒç´ åœ¨æ‰€æœ‰æ—¶é—´åºåˆ—ä¸­çš„**ç»Ÿè®¡åˆ†å¸ƒç‰¹å¾**ï¼Œè¯†åˆ«å‡ºé‚£äº›**è¡Œä¸ºæ¨¡å¼å¼‚å¸¸**çš„åƒç´ ç‚¹ã€‚


```python
# æ ¸å¿ƒç®—æ³•é€»è¾‘
m = normalized_data[MASK].mean(axis=0, dtype=np.float64)  # è®¡ç®—å‡å€¼
S = np.cov(normalized_data[MASK], rowvar=False)           # è®¡ç®—åæ–¹å·®çŸ©é˜µ
Sinv = np.linalg.pinv(S)                                  # è®¡ç®—é€†çŸ©é˜µ

# å¯¹æ¯ä¸ªåƒç´ è®¡ç®—é©¬å“ˆæ‹‰è¯ºæ¯”æ–¯è·ç¦»
distances[i][j] = mahalanobis(normalized_data[i][j], m, Sinv)

# ä½¿ç”¨3å€æ ‡å‡†å·®ä½œä¸ºå¼‚å¸¸å€¼é˜ˆå€¼
mask = distances <= dist_mean + 3 * dist_stddev
```

### 2. åœ°å½¢å¯¹é›·è¾¾ä¿¡å·çš„å½±å“æœºåˆ¶

æ‚¨å›¾ç‰‡ä¸­æ˜¾ç¤ºçš„ç°è±¡ç¡®å®ä¸åœ°å½¢å¯†åˆ‡ç›¸å…³ï¼š

#### ğŸŒ„ **åœ°å½¢é®æŒ¡æ•ˆåº”**
- **å±±è„‰é®æŒ¡**ï¼šé«˜æµ·æ‹”åœ°å½¢ä¼šé˜»æŒ¡é›·è¾¾æ³¢æŸï¼Œé€ æˆ**é˜´å½±åŒºåŸŸ**
- **å¤šå¾„åå°„**ï¼šå¤æ‚åœ°å½¢å¯¼è‡´é›·è¾¾ä¿¡å·äº§ç”Ÿ**å¤šæ¬¡åå°„**ï¼Œå½¢æˆè™šå‡å›æ³¢
- **æ³¢æŸå¼¯æ›²**ï¼šå¤§æ°”æŠ˜å°„ä½¿é›·è¾¾æ³¢æŸè·¯å¾„å‘ç”Ÿå¼¯æ›²ï¼Œå½±å“è¿œè·ç¦»æ¢æµ‹

#### ğŸ“Š **å™ªå£°åˆ†å¸ƒç‰¹å¾**
ä»æ‚¨çš„å›¾ç‰‡å¯ä»¥çœ‹å‡ºï¼š
- **å·¦å›¾**ï¼šå™ªå£°ä¸»è¦é›†ä¸­åœ¨**å±±è°·å’Œä½æµ·æ‹”åŒºåŸŸ**
- **å³å›¾**ï¼šå¼‚å¸¸å€¼æ©è†œä¸­çš„é»‘è‰²åŒºåŸŸä¸å·¦å›¾çš„å™ªå£°åˆ†å¸ƒ**é«˜åº¦å»åˆ**
- **ç³»ç»Ÿæ€§ä¼ªå½±**ï¼šè¿™äº›å¼‚å¸¸å€¼ä¸æ˜¯éšæœºçš„ï¼Œè€Œæ˜¯ä¸åœ°å½¢ç‰¹å¾**ç³»ç»Ÿæ€§ç›¸å…³**

#### ï¿½ï¿½ **ç‰©ç†æœºåˆ¶**
```python
# åœ¨settings.pyä¸­å¯ä»¥çœ‹åˆ°é›·è¾¾çš„åŸºæœ¬å‚æ•°
RADIUS = IMG_SIZE / 2  # é›·è¾¾æ‰«æåŠå¾„
SCAN_MIN_VALUE = 0     # æœ€å°åå°„ç‡å€¼
SCAN_MAX_VALUE = 52.5  # æœ€å¤§åå°„ç‡å€¼ï¼ˆdBZï¼‰
```


```python
# åœ¨settings.pyä¸­å¯ä»¥çœ‹åˆ°é›·è¾¾çš„åŸºæœ¬å‚æ•°
RADIUS = IMG_SIZE / 2  # é›·è¾¾æ‰«æåŠå¾„
SCAN_MIN_VALUE = 0     # æœ€å°åå°„ç‡å€¼
SCAN_MAX_VALUE = 52.5  # æœ€å¤§åå°„ç‡å€¼ï¼ˆdBZï¼‰
```

```python
# åœ¨settings.pyä¸­å¯ä»¥çœ‹åˆ°é›·è¾¾çš„åŸºæœ¬å‚æ•°
RADIUS = IMG_SIZE / 2  # é›·è¾¾æ‰«æåŠå¾„
SCAN_MIN_VALUE = 0     # æœ€å°åå°„ç‡å€¼
SCAN_MAX_VALUE = 52.5  # æœ€å¤§åå°„ç‡å€¼ï¼ˆdBZï¼‰
```

### 3. è®­ç»ƒæ—¶æ©è†œä½¿ç”¨çš„å¿…è¦æ€§

ä»ä»£ç åˆ†æå¯ä»¥çœ‹å‡ºï¼Œ**æ©è†œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­æ˜¯ç»å¯¹å¿…è¦çš„**ï¼š

#### ğŸ¯ **æ•°æ®è¿­ä»£å™¨ä¸­çš„æ©è†œåº”ç”¨**
```python
# åœ¨taasrad19.pyçš„HDFIteratorç±»ä¸­
def _compute_mask(self, img):
    mask = np.zeros_like(img, dtype=np.bool)
    mask[:] = np.broadcast_to(self.outlier_mask.astype(np.bool), shape=img.shape)
    mask[np.logical_and(img < self.filter_threshold, img > 0)] = 0
    return mask
```

#### ï¿½ï¿½ **æŸå¤±å‡½æ•°ä¸­çš„æ©è†œæƒé‡**
```python
# åœ¨radar_evaluation.pyä¸­
mse = (mask * np.square(pred - gt)).sum(axis=(2, 3, 4))
mae = (mask * np.abs(pred - gt)).sum(axis=(2, 3, 4))
```

#### ï¿½ï¿½ **è®­ç»ƒè¿‡ç¨‹ä¸­çš„æ©è†œå¤„ç†**
```python
# åœ¨encoder_forecaster.pyä¸­
if cfg.MODEL.ENCODER_FORECASTER.HAS_MASK:
    loss_net.forward_backward(data_batch=mx.io.DataBatch(data=[pred_nd],
                                                         label=[gt_nd, mask_nd]))
```

**å…³é”®ä½œç”¨**ï¼š
1. **é˜²æ­¢å¼‚å¸¸å€¼æ±¡æŸ“**ï¼šé¿å…åœ°å½¢ç›¸å…³çš„è™šå‡ä¿¡å·å½±å“æ¨¡å‹å­¦ä¹ 
2. **æé«˜é¢„æµ‹ç²¾åº¦**ï¼šç¡®ä¿æ¨¡å‹åªå­¦ä¹ çœŸå®çš„æ°”è±¡ä¿¡å·
3. **ç¨³å®šè®­ç»ƒè¿‡ç¨‹**ï¼šå‡å°‘å™ªå£°å¯¹æ¢¯åº¦è®¡ç®—çš„å¹²æ‰°


```python
# åœ¨taasrad19.pyçš„HDFIteratorç±»ä¸­
def _compute_mask(self, img):
    mask = np.zeros_like(img, dtype=np.bool)
    mask[:] = np.broadcast_to(self.outlier_mask.astype(np.bool), shape=img.shape)
    mask[np.logical_and(img < self.filter_threshold, img > 0)] = 0
    return mask
```

```python
# åœ¨radar_evaluation.pyä¸­
mse = (mask * np.square(pred - gt)).sum(axis=(2, 3, 4))
mae = (mask * np.abs(pred - gt)).sum(axis=(2, 3, 4))
```

```python
# åœ¨taasrad19.pyçš„HDFIteratorç±»ä¸­
def _compute_mask(self, img):
    mask = np.zeros_like(img, dtype=np.bool)
    mask[:] = np.broadcast_to(self.outlier_mask.astype(np.bool), shape=img.shape)
    mask[np.logical_and(img < self.filter_threshold, img > 0)] = 0
    return mask
```

```python
# åœ¨radar_evaluation.pyä¸­
mse = (mask * np.square(pred - gt)).sum(axis=(2, 3, 4))
mae = (mask * np.abs(pred - gt)).sum(axis=(2, 3, 4))
```

```python
# åœ¨encoder_forecaster.pyä¸­
if cfg.MODEL.ENCODER_FORECASTER.HAS_MASK:
    loss_net.forward_backward(data_batch=mx.io.DataBatch(data=[pred_nd],
                                                         label=[gt_nd, mask_nd]))
```

### 4. å›¾ç‰‡åˆ†æï¼šå¼‚å¸¸å€¼åˆ†å¸ƒä¸åœ°å½¢çš„å¯¹åº”å…³ç³»

åŸºäºæ‚¨æä¾›çš„å›¾ç‰‡ï¼Œæˆ‘å¯ä»¥ç¡®è®¤æ‚¨çš„åˆ†æï¼š

#### ï¿½ï¿½ï¸ **ç©ºé—´å¯¹åº”å…³ç³»**
- **å·¦å›¾**ï¼šå™ªå£°å€¼ï¼ˆ0.1-21.6ï¼‰ä¸»è¦é›†ä¸­åœ¨**å±±è°·å’Œä½æµ·æ‹”åŒºåŸŸ**
- **å³å›¾**ï¼šå¼‚å¸¸å€¼æ©è†œä¸­çš„é»‘è‰²åŒºåŸŸä¸å·¦å›¾å™ªå£°åˆ†å¸ƒ**å®Œç¾å¯¹åº”**
- **330Ã—330è¾¹ç•Œ**ï¼šå®šä¹‰äº†é›·è¾¾æœ‰æ•ˆæ‰«æåŒºåŸŸ

#### ï¿½ï¿½ **æŠ€æœ¯éªŒè¯**
```python
# ä»settings.pyå¯ä»¥çœ‹å‡º
CROP_SIZE = 480  # è¾“å‡ºå›¾åƒå°ºå¯¸
PARSE_OFFSET = (IMG_SIZE - CROP_SIZE) // 2  # è£å‰ªåç§»
```

#### ğŸ“Š **å¼‚å¸¸å€¼è¯†åˆ«é€»è¾‘**
1. **ç»Ÿè®¡å¼‚å¸¸**ï¼šé€šè¿‡é©¬å“ˆæ‹‰è¯ºæ¯”æ–¯è·ç¦»è¯†åˆ«ç»Ÿè®¡åˆ†å¸ƒå¼‚å¸¸çš„åƒç´ 
2. **åœ°å½¢ç›¸å…³**ï¼šè¿™äº›å¼‚å¸¸å€¼ä¸»è¦å‡ºç°åœ¨åœ°å½¢å¤æ‚çš„åŒºåŸŸ
3. **ç³»ç»Ÿæ€§ç‰¹å¾**ï¼šä¸æ˜¯éšæœºå™ªå£°ï¼Œè€Œæ˜¯ä¸åœ°å½¢ç‰¹å¾ç›¸å…³çš„ç³»ç»Ÿæ€§ä¼ªå½±


```python
# ä»settings.pyå¯ä»¥çœ‹å‡º
CROP_SIZE = 480  # è¾“å‡ºå›¾åƒå°ºå¯¸
PARSE_OFFSET = (IMG_SIZE - CROP_SIZE) // 2  # è£å‰ªåç§»
```

```python
# ä»settings.pyå¯ä»¥çœ‹å‡º
CROP_SIZE = 480  # è¾“å‡ºå›¾åƒå°ºå¯¸
PARSE_OFFSET = (IMG_SIZE - CROP_SIZE) // 2  # è£å‰ªåç§»
```

## ğŸ¯ æ€»ç»“å›ç­”

**æ‚¨çš„åˆ†æå®Œå…¨æ­£ç¡®ï¼** å³å›¾ä¸­é—´çš„é»‘è‰²åƒç´ ç¡®å®æ˜¯å¼‚å¸¸å€¼ï¼Œè¿™äº›å¼‚å¸¸å€¼**å¾ˆå¤§ç¨‹åº¦ä¸Šæ˜¯ç”±åœ°å½¢åŸå› é€ æˆçš„**ï¼Œå› æ­¤åœ¨è®­ç»ƒæ—¶å¿…é¡»å°†æ‰€æœ‰å¸§çš„å¼‚å¸¸åŒºåŸŸmaskæ‰ã€‚

### ï¿½ï¿½ **æ ¸å¿ƒè¦ç‚¹**ï¼š

1. **åœ°å½¢å½±å“æœºåˆ¶**ï¼š
   - å±±è„‰é®æŒ¡é€ æˆé›·è¾¾é˜´å½±åŒºåŸŸ
   - å¤æ‚åœ°å½¢å¯¼è‡´å¤šå¾„åå°„å’Œæ³¢æŸå¼¯æ›²
   - å±±è°·åŒºåŸŸå®¹æ˜“äº§ç”Ÿç³»ç»Ÿæ€§ä¼ªå½±

2. **æ©è†œç”ŸæˆåŸç†**ï¼š
   - ä½¿ç”¨é©¬å“ˆæ‹‰è¯ºæ¯”æ–¯è·ç¦»è¯†åˆ«ç»Ÿè®¡å¼‚å¸¸åƒç´ 
   - åŸºäº3å€æ ‡å‡†å·®é˜ˆå€¼ç¡®å®šå¼‚å¸¸å€¼
   - å¼‚å¸¸å€¼åˆ†å¸ƒä¸åœ°å½¢ç‰¹å¾é«˜åº¦ç›¸å…³

3. **è®­ç»ƒå¿…è¦æ€§**ï¼š
   - é˜²æ­¢åœ°å½¢ç›¸å…³è™šå‡ä¿¡å·æ±¡æŸ“æ¨¡å‹
   - æé«˜é™æ°´é¢„æµ‹çš„å‡†ç¡®æ€§
   - ç¡®ä¿æ¨¡å‹å­¦ä¹ çœŸå®çš„æ°”è±¡ä¿¡å·

4. **å®é™…åº”ç”¨**ï¼š
   - æ©è†œåœ¨æ•°æ®åŠ è½½ã€æŸå¤±è®¡ç®—ã€æ¨¡å‹è¯„ä¼°ä¸­å…¨ç¨‹ä½¿ç”¨
   - å¼‚å¸¸å€¼åŒºåŸŸåœ¨è®­ç»ƒå’Œé¢„æµ‹æ—¶éƒ½è¢«æ’é™¤
   - è¿™æ˜¯æ°”è±¡é›·è¾¾æ·±åº¦å­¦ä¹ é¡¹ç›®çš„æ ‡å‡†åšæ³•

æ‚¨çš„ç†è§£éå¸¸æ·±å…¥ï¼Œè¿™æ­£æ˜¯æ°”è±¡é›·è¾¾æ•°æ®å¤„ç†ä¸­çš„æ ¸å¿ƒæŒ‘æˆ˜ä¹‹ä¸€ï¼è¿™ç§åœ°å½¢ç›¸å…³çš„ç³»ç»Ÿæ€§ä¼ªå½±å¤„ç†æ˜¯ç¡®ä¿æ¨¡å‹é¢„æµ‹å‡†ç¡®æ€§çš„å…³é”®æ­¥éª¤ã€‚

---

**User**

é‚£åœ¨é¢„æµ‹çš„æ—¶å€™è¿™äº›åŒºåŸŸæ€ä¹ˆå¤„ç†å‘¢ï¼Œé›·è¾¾èŒƒå›´å¤–çš„æ•°æ®æˆ‘å¯ä»¥å…¨ç½®ä¸º0ï¼Œä¸­å¿ƒçš„è¿™äº›å¼‚å¸¸åŒºåŸŸæ˜¯ä¸æ˜¯å¯ä»¥ç”¨æœ€è¿‘çš„å€¼å¡«å……ï¼Ÿ

---

**Cursor**

æ‚¨çš„é—®é¢˜éå¸¸å®ç”¨ï¼è®©æˆ‘æŸ¥çœ‹ä¸€ä¸‹TAASRAD19é¡¹ç›®ä¸­é¢„æµ‹æ—¶æ˜¯å¦‚ä½•å¤„ç†è¿™äº›å¼‚å¸¸åŒºåŸŸçš„ã€‚


ç°åœ¨è®©æˆ‘åˆ›å»ºä¸€ä¸ªä»»åŠ¡åˆ—è¡¨æ¥è¯¦ç»†å›ç­”æ‚¨å…³äºé¢„æµ‹æ—¶å¼‚å¸¸åŒºåŸŸå¤„ç†çš„é—®é¢˜ï¼š


åŸºäºå¯¹TAASRAD19é¡¹ç›®é¢„æµ‹ä»£ç çš„æ·±å…¥åˆ†æï¼Œæˆ‘æ¥è¯¦ç»†å›ç­”æ‚¨å…³äºé¢„æµ‹æ—¶å¼‚å¸¸åŒºåŸŸå¤„ç†çš„é—®é¢˜ï¼š

## ï¿½ï¿½ é¢„æµ‹æ—¶çš„å¼‚å¸¸åŒºåŸŸå¤„ç†ç­–ç•¥

### 1. **TAASRAD19é¡¹ç›®çš„å®é™…åšæ³•**

ä» `predict.py` ä»£ç å¯ä»¥çœ‹å‡ºï¼Œé¡¹ç›®é‡‡ç”¨äº†**NaNå¡«å……ç­–ç•¥**ï¼š

```python
# å…³é”®ä»£ç ç‰‡æ®µ
pred_frame[~mask_out] = np.nan  # é¢„æµ‹ç»“æœä¸­é›·è¾¾èŒƒå›´å¤–åŒºåŸŸè®¾ä¸ºNaN
out_frame[~mask_out] = np.nan   # çœŸå®å€¼ä¸­é›·è¾¾èŒƒå›´å¤–åŒºåŸŸè®¾ä¸ºNaN  
in_frame[~mask_in] = np.nan     # è¾“å…¥æ•°æ®ä¸­é›·è¾¾èŒƒå›´å¤–åŒºåŸŸè®¾ä¸ºNaN
```

**æ ¸å¿ƒç­–ç•¥**ï¼š
- **é›·è¾¾èŒƒå›´å¤–**ï¼šç›´æ¥è®¾ä¸º `np.nan`
- **å¼‚å¸¸å€¼åŒºåŸŸ**ï¼šé€šè¿‡æ©è†œè¯†åˆ«åä¹Ÿè®¾ä¸º `np.nan`
- **ä¸è¿›è¡Œæ’å€¼å¡«å……**ï¼šä¿æŒæ•°æ®çš„åŸå§‹çŠ¶æ€

### 2. **ä¸ºä»€ä¹ˆä½¿ç”¨NaNè€Œä¸æ˜¯æ’å€¼å¡«å……ï¼Ÿ**

#### ğŸ”¬ **ç§‘å­¦åˆç†æ€§**
```python
# ä»ä»£ç å¯ä»¥çœ‹å‡ºæ©è†œçš„ä½¿ç”¨é€»è¾‘
radar_mask = radar_circle_mask()  # åœ†å½¢é›·è¾¾æ‰«æèŒƒå›´
outlier_mask = cv2.imread(os.path.join(args.data_dir, 'mask.png'), 0)  # å¼‚å¸¸å€¼æ©è†œ
```

**åŸå› åˆ†æ**ï¼š
1. **æ•°æ®å®Œæ•´æ€§**ï¼šNaNè¡¨ç¤º"æœªçŸ¥"ï¼Œæ¯”é”™è¯¯çš„æ’å€¼æ›´è¯šå®
2. **é¿å…è¯¯å¯¼**ï¼šæ’å€¼å¯èƒ½äº§ç”Ÿè™šå‡çš„æ°”è±¡ä¿¡å·
3. **è¯„ä¼°å‡†ç¡®æ€§**ï¼šåœ¨æ¨¡å‹è¯„ä¼°æ—¶ï¼ŒNaNåŒºåŸŸè¢«æ­£ç¡®æ’é™¤

#### ğŸ“Š **è¯„ä¼°æ—¶çš„å¤„ç†**
```python
# åœ¨radar_evaluation.pyä¸­
mse = (mask * np.square(pred - gt)).sum(axis=(2, 3, 4))
mae = (mask * np.abs(pred - gt)).sum(axis=(2, 3, 4))
```
æ©è†œç¡®ä¿åªæœ‰æœ‰æ•ˆåŒºåŸŸå‚ä¸è¯„ä¼°è®¡ç®—ã€‚

### 3. **æ‚¨æå‡ºçš„å¡«å……ç­–ç•¥åˆ†æ**

#### âœ… **é›·è¾¾èŒƒå›´å¤–ç½®0çš„ç­–ç•¥**
```python
# æ‚¨çš„å»ºè®®ï¼šé›·è¾¾èŒƒå›´å¤–æ•°æ®å…¨ç½®ä¸º0
def handle_radar_outside(data, radar_mask):
    data[~radar_mask] = 0  # é›·è¾¾èŒƒå›´å¤–è®¾ä¸º0
    return data
```

**ä¼˜ç‚¹**ï¼š
- ç®€å•ç›´æ¥
- ç¬¦åˆç‰©ç†ç›´è§‰ï¼ˆæ— é›·è¾¾ä¿¡å·=0åå°„ç‡ï¼‰
- è®¡ç®—æ•ˆç‡é«˜

#### âš ï¸ **å¼‚å¸¸åŒºåŸŸæœ€è¿‘å€¼å¡«å……çš„è€ƒè™‘**

**æ½œåœ¨é—®é¢˜**ï¼š
1. **å¼•å…¥è™šå‡ä¿¡å·**ï¼šæœ€è¿‘å€¼å¯èƒ½æ¥è‡ªå®Œå…¨ä¸åŒçš„æ°”è±¡æ¡ä»¶
2. **ç ´åç©ºé—´è¿ç»­æ€§**ï¼šå¯èƒ½äº§ç”Ÿä¸çœŸå®çš„é™æ°´æ¨¡å¼
3. **å½±å“æ¨¡å‹å­¦ä¹ **ï¼šå¦‚æœè®­ç»ƒæ—¶ç”¨æ©è†œï¼Œé¢„æµ‹æ—¶ç”¨å¡«å……ï¼Œä¼šé€ æˆä¸ä¸€è‡´

### 4. **æ¨èçš„å®ç°ç­–ç•¥**

#### ï¿½ï¿½ **æ–¹æ¡ˆä¸€ï¼šä¿æŒä¸€è‡´æ€§ï¼ˆæ¨èï¼‰**
```python
def predict_with_consistent_masking(input_data, model, outlier_mask, radar_mask):
    """
    ä¿æŒä¸è®­ç»ƒæ—¶ä¸€è‡´çš„æ©è†œç­–ç•¥
    """
    # åº”ç”¨å¼‚å¸¸å€¼æ©è†œ
    input_data[outlier_mask == 0] = np.nan
    
    # æ¨¡å‹é¢„æµ‹
    prediction = model.predict(input_data)
    
    # åº”ç”¨é›·è¾¾èŒƒå›´æ©è†œ
    prediction[~radar_mask] = np.nan
    
    return prediction
```

#### ğŸ”„ **æ–¹æ¡ˆäºŒï¼šæ™ºèƒ½å¡«å……ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰**
```python
def predict_with_smart_filling(input_data, model, outlier_mask, radar_mask):
    """
    ä»…åœ¨å¿…è¦æ—¶è¿›è¡Œå¡«å……
    """
    # ä¿å­˜åŸå§‹æ©è†œ
    valid_mask = radar_mask & (outlier_mask > 0)
    
    # æ¨¡å‹é¢„æµ‹
    prediction = model.predict(input_data)
    
    # é›·è¾¾èŒƒå›´å¤–ç½®0
    prediction[~radar_mask] = 0
    
    # å¼‚å¸¸åŒºåŸŸä½¿ç”¨ç©ºé—´æ’å€¼ï¼ˆå¯é€‰ï¼‰
    if np.any(outlier_mask == 0):
        prediction = spatial_interpolation(prediction, valid_mask)
    
    return prediction

def spatial_interpolation(data, valid_mask):
    """
    ç©ºé—´æ’å€¼å¡«å……å¼‚å¸¸åŒºåŸŸ
    """
    from scipy.interpolate import griddata
    
    # è·å–æœ‰æ•ˆåƒç´ åæ ‡
    valid_coords = np.where(valid_mask)
    valid_values = data[valid_coords]
    
    # è·å–éœ€è¦å¡«å……çš„åæ ‡
    invalid_coords = np.where(~valid_mask)
    
    if len(invalid_coords[0]) > 0:
        # è¿›è¡Œæ’å€¼
        filled_values = griddata(
            (valid_coords[0], valid_coords[1]), 
            valid_values,
            (invalid_coords[0], invalid_coords[1]),
            method='nearest'  # æˆ– 'linear', 'cubic'
        )
        data[invalid_coords] = filled_values
    
    return data
```

### 5. **å®é™…åº”ç”¨å»ºè®®**

#### ğŸ¯ **ç”Ÿäº§ç¯å¢ƒæ¨è**
```python
def production_predict(input_data, model, outlier_mask, radar_mask):
    """
    ç”Ÿäº§ç¯å¢ƒä¸‹çš„é¢„æµ‹å¤„ç†
    """
    # 1. åº”ç”¨æ©è†œ
    input_data[outlier_mask == 0] = np.nan
    input_data[~radar_mask] = np.nan
    
    # 2. æ¨¡å‹é¢„æµ‹
    prediction = model.predict(input_data)
    
    # 3. åå¤„ç†
    prediction[~radar_mask] = 0  # é›·è¾¾èŒƒå›´å¤–ç½®0
    prediction[outlier_mask == 0] = np.nan  # å¼‚å¸¸åŒºåŸŸä¿æŒNaN
    
    # 4. å¯é€‰ï¼šå¼‚å¸¸åŒºåŸŸä½¿ç”¨æœ€è¿‘é‚»å¡«å……
    if np.any(outlier_mask == 0):
        prediction = fill_anomaly_regions(prediction, outlier_mask)
    
    return prediction

def fill_anomaly_regions(data, outlier_mask):
    """
    ä½¿ç”¨æœ€è¿‘é‚»å¡«å……å¼‚å¸¸åŒºåŸŸ
    """
    from scipy.ndimage import distance_transform_edt
    
    # è®¡ç®—åˆ°æœ€è¿‘æœ‰æ•ˆåƒç´ çš„è·ç¦»
    valid_mask = outlier_mask > 0
    distances, indices = distance_transform_edt(~valid_mask, return_indices=True)
    
    # ç”¨æœ€è¿‘æœ‰æ•ˆåƒç´ çš„å€¼å¡«å……
    filled_data = data.copy()
    filled_data[~valid_mask] = data[tuple(indices[:, ~valid_mask])]
    
    return filled_data
```

## ï¿½ï¿½ æ€»ç»“å»ºè®®

1. **é›·è¾¾èŒƒå›´å¤–**ï¼šç½®0æ˜¯åˆç†çš„ï¼Œç¬¦åˆç‰©ç†ç›´è§‰
2. **å¼‚å¸¸åŒºåŸŸ**ï¼šå»ºè®®ä¿æŒNaNï¼Œæˆ–ä½¿ç”¨æœ€è¿‘é‚»å¡«å……
3. **ä¸€è‡´æ€§åŸåˆ™**ï¼šè®­ç»ƒå’Œé¢„æµ‹æ—¶çš„å¤„ç†ç­–ç•¥åº”ä¿æŒä¸€è‡´
4. **è¯„ä¼°å‡†ç¡®æ€§**ï¼šç¡®ä¿æ©è†œåŒºåŸŸä¸å‚ä¸æ¨¡å‹æ€§èƒ½è¯„ä¼°

æ‚¨çš„æ€è·¯å¾ˆæ­£ç¡®ï¼Œå…³é”®æ˜¯è¦åœ¨æ•°æ®å®Œæ•´æ€§å’Œå®ç”¨æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼

```python
# å…³é”®ä»£ç ç‰‡æ®µ
pred_frame[~mask_out] = np.nan  # é¢„æµ‹ç»“æœä¸­é›·è¾¾èŒƒå›´å¤–åŒºåŸŸè®¾ä¸ºNaN
out_frame[~mask_out] = np.nan   # çœŸå®å€¼ä¸­é›·è¾¾èŒƒå›´å¤–åŒºåŸŸè®¾ä¸ºNaN  
in_frame[~mask_in] = np.nan     # è¾“å…¥æ•°æ®ä¸­é›·è¾¾èŒƒå›´å¤–åŒºåŸŸè®¾ä¸ºNaN
```

```python
# ä»ä»£ç å¯ä»¥çœ‹å‡ºæ©è†œçš„ä½¿ç”¨é€»è¾‘
radar_mask = radar_circle_mask()  # åœ†å½¢é›·è¾¾æ‰«æèŒƒå›´
outlier_mask = cv2.imread(os.path.join(args.data_dir, 'mask.png'), 0)  # å¼‚å¸¸å€¼æ©è†œ
```

```python
# åœ¨radar_evaluation.pyä¸­
mse = (mask * np.square(pred - gt)).sum(axis=(2, 3, 4))
mae = (mask * np.abs(pred - gt)).sum(axis=(2, 3, 4))
```

```python
# æ‚¨çš„å»ºè®®ï¼šé›·è¾¾èŒƒå›´å¤–æ•°æ®å…¨ç½®ä¸º0
def handle_radar_outside(data, radar_mask):
    data[~radar_mask] = 0  # é›·è¾¾èŒƒå›´å¤–è®¾ä¸º0
    return data
```

```python
def predict_with_consistent_masking(input_data, model, outlier_mask, radar_mask):
    """
    ä¿æŒä¸è®­ç»ƒæ—¶ä¸€è‡´çš„æ©è†œç­–ç•¥
    """
    # åº”ç”¨å¼‚å¸¸å€¼æ©è†œ
    input_data[outlier_mask == 0] = np.nan
    
    # æ¨¡å‹é¢„æµ‹
    prediction = model.predict(input_data)
    
    # åº”ç”¨é›·è¾¾èŒƒå›´æ©è†œ
    prediction[~radar_mask] = np.nan
    
    return prediction
```

```python
def predict_with_smart_filling(input_data, model, outlier_mask, radar_mask):
    """
    ä»…åœ¨å¿…è¦æ—¶è¿›è¡Œå¡«å……
    """
    # ä¿å­˜åŸå§‹æ©è†œ
    valid_mask = radar_mask & (outlier_mask > 0)
    
    # æ¨¡å‹é¢„æµ‹
    prediction = model.predict(input_data)
    
    # é›·è¾¾èŒƒå›´å¤–ç½®0
    prediction[~radar_mask] = 0
    
    # å¼‚å¸¸åŒºåŸŸä½¿ç”¨ç©ºé—´æ’å€¼ï¼ˆå¯é€‰ï¼‰
    if np.any(outlier_mask == 0):
        prediction = spatial_interpolation(prediction, valid_mask)
    
    return prediction

def spatial_interpolation(data, valid_mask):
    """
    ç©ºé—´æ’å€¼å¡«å……å¼‚å¸¸åŒºåŸŸ
    """
    from scipy.interpolate import griddata
    
    # è·å–æœ‰æ•ˆåƒç´ åæ ‡
    valid_coords = np.where(valid_mask)
    valid_values = data[valid_coords]
    
    # è·å–éœ€è¦å¡«å……çš„åæ ‡
    invalid_coords = np.where(~valid_mask)
    
    if len(invalid_coords[0]) > 0:
        # è¿›è¡Œæ’å€¼
        filled_values = griddata(
            (valid_coords[0], valid_coords[1]), 
            valid_values,
            (invalid_coords[0], invalid_coords[1]),
            method='nearest'  # æˆ– 'linear', 'cubic'
        )
        data[invalid_coords] = filled_values
    
    return data
```

```python
def production_predict(input_data, model, outlier_mask, radar_mask):
    """
    ç”Ÿäº§ç¯å¢ƒä¸‹çš„é¢„æµ‹å¤„ç†
    """
    # 1. åº”ç”¨æ©è†œ
    input_data[outlier_mask == 0] = np.nan
    input_data[~radar_mask] = np.nan
    
    # 2. æ¨¡å‹é¢„æµ‹
    prediction = model.predict(input_data)
    
    # 3. åå¤„ç†
    prediction[~radar_mask] = 0  # é›·è¾¾èŒƒå›´å¤–ç½®0
    prediction[outlier_mask == 0] = np.nan  # å¼‚å¸¸åŒºåŸŸä¿æŒNaN
    
    # 4. å¯é€‰ï¼šå¼‚å¸¸åŒºåŸŸä½¿ç”¨æœ€è¿‘é‚»å¡«å……
    if np.any(outlier_mask == 0):
        prediction = fill_anomaly_regions(prediction, outlier_mask)
    
    return prediction

def fill_anomaly_regions(data, outlier_mask):
    """
    ä½¿ç”¨æœ€è¿‘é‚»å¡«å……å¼‚å¸¸åŒºåŸŸ
    """
    from scipy.ndimage import distance_transform_edt
    
    # è®¡ç®—åˆ°æœ€è¿‘æœ‰æ•ˆåƒç´ çš„è·ç¦»
    valid_mask = outlier_mask > 0
    distances, indices = distance_transform_edt(~valid_mask, return_indices=True)
    
    # ç”¨æœ€è¿‘æœ‰æ•ˆåƒç´ çš„å€¼å¡«å……
    filled_data = data.copy()
    filled_data[~valid_mask] = data[tuple(indices[:, ~valid_mask])]
    
    return filled_data
```

